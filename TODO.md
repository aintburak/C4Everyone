# 📘 C++ Programming Language Course Content

## 🌟 General Introduction to C++
- [ ] History of C++
- [ ] C++ and programming paradigms
- [ ] C++ language standards
- [ ] C++98 – C++03
- [ ] C++11
- [ ] C++14
- [ ] C++17
- [ ] C++20
- [ ] Differences between old C++ and modern C++

## 🔍 C Language and C in C++
- [ ] Transition from C to C++
- [ ] Differences in function declarations and definitions
- [ ] Differences in types and type conversions
- [ ] Valid in C, invalid in C++ situations
- [ ] C99 and C++

## 📚 Basic Concepts
- [ ] Complete and incomplete types
- [ ] One definition rule
- [ ] Value categories of expressions
- [ ] Undefined behavior
- [ ] Implementation-defined and implementation-specified behaviors
- [ ] Compiler extensions
- [ ] Scope and name lookup
- [ ] Access control
- [ ] Ambiguity errors

## 🛠 Initialization
- [ ] Uniform initialization
- [ ] Narrowing conversions
- [ ] Most vexing parse
- [ ] Direct initialization
- [ ] Value initialization
- [ ] Copy initialization
- [ ] Default initialization
- [ ] Aggregate initialization

## 📏 Type Deduction
- [ ] Auto type deduction
- [ ] Decltype type deduction
- [ ] Trailing return type
- [ ] Auto return type
- [ ] Decltype auto

## 🚦 Scoped Enum Types
- [ ] Conventional enum types
- [ ] Underlying type selection
- [ ] Type conversions
- [ ] Enum classes and scope
- [ ] Using enum declarations (C++20)

## 🧮 Constant Expressions
- [ ] Const keyword and const semantics
- [ ] Const objects
- [ ] Constexpr keyword
- [ ] Constexpr functions
- [ ] Consteval functions - C++20
- [ ] Constinit keyword - C++20

## 📎 Reference Semantics
- [ ] L value references
- [ ] R value references
- [ ] References and const semantics
- [ ] Comparison of references and pointers
- [ ] Functions that take references as parameters
- [ ] Functions returning references
- [ ] Reference life extension

## 🔄 Function Overloading
- [ ] General rules
- [ ] Function overload resolution
- [ ] Const overloading
- [ ] Extern "C" declarations
- [ ] Considerations in function overloading

## 🔄 Type-cast Operators
- [ ] Static_cast<>
- [ ] Const_cast<>
- [ ] Reinterpret_cast<>
- [ ] Dynamic_cast<> (under inheritance)

## 🏃 Inline Functions and Variables
- [ ] One definition rule
- [ ] Inline functions
- [ ] Inline variables (C++17)

## 🏛 Introduction to Classes
- [ ] Class scope
- [ ] Classes and name lookup
- [ ] Access control and data hiding
  - [ ] Public members
  - [ ] Private members
  - [ ] Protected members
- [ ] Class members
  - [ ] Data members
    - [ ] Non-static data members
    - [ ] Mutable data members
    - [ ] Static data members
  - [ ] Member functions
    - [ ] Non-static member functions
    - [ ] Const member functions
    - [ ] Static member functions
  - [ ] The `this` pointer and `*this`
  - [ ] Type members of classes
- [ ] Constructors of classes
  - [ ] Constructor initializer list
  - [ ] Delegating constructors
  - [ ] Explicit constructors
- [ ] Destructors of classes
- [ ] Calling member functions
- [ ] Classes and const correctness
  - [ ] Const class objects
  - [ ] Const member functions
- [ ] Temporary class objects
- [ ] Implicit type conversions
- [ ] Mutable keyword
- [ ] Friend declarations
  - [ ] Friend declaration and data hiding
  - [ ] Friend declarations to global functions
  - [ ] Friend declarations to member functions of classes
  - [ ] Friend declarations to classes
  - [ ] Attorney-client idiom

## 🧩 Special Member Functions and Copy Control
- [ ] Special functions of classes
  - [ ] Default constructor
  - [ ] Destructor
  - [ ] Copy constructor
  - [ ] Move constructor
  - [ ] Copy assignment
  - [ ] Move assignment
- [ ] Defaulting special functions
- [ ] Deleting special functions
- [ ] Classes and move semantics
- [ ] Rule of zero
- [ ] Rule of five
- [ ] Copy-and-swap idiom
- [ ] Copy elision
  - [ ] Copy elision through temporaries
  - [ ] Return value optimization (RVO)
  - [ ] Named return value optimization (NRVO)
  - [ ] Mandatory copy elision

## ⚙️ Operator Overloading
- [ ] General rules of operator overloading
- [ ] Member operator functions
- [ ] Global operator functions
- [ ] Overloading arithmetic operators
- [ ] Overloading comparison operators
- [ ] 3-way comparison operator (C++20)
- [ ] Overloading "++" and "--" operators
- [ ] Overloading the arrow and dereferencing operators
- [ ] Overloading the subscript operator
- [ ] Overloading the function call operator
- [ ] Type-cast operator functions
- [ ] User-defined literals

